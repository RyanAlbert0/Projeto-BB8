<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="../imagens/icon-bb8.png">
    <title>Editar Montagem de Saída - BB8: Archaeologist</title>
</head>
<body>
    <div id="header">
        <button onclick="window.location.href = '../interface/interface.html'" id="home"><img src="../imagens/casa.png" width="50" height="50"></button>
        <h1>Editar Montagem de Saída - BB8: Archaeologist</h1>
        <img src="../imagens/Logo SESI 2.png" id="logoSESI">
    </div>
    <div id="content">
        <div id="img">
        <canvas id="mesa" width="1280" height="720" style="border: 1px solid black;"></canvas>
        <img src="../imagens/table.jpg" id="mesaIMG" style="display: none;">
        </div>
    </div>
    <div id="userInputs">
        <select id="seletorSaida">
            <option value='null' disabled hidden selected>Selecione uma saída</option>
        </select>
        <select id="seletorPonto">
            <option value="" disabled hidden selected>Selecione um ponto</option>
        </select>
        <button id="editarBase" onclick="editarBase()">Editar Base</button>
        <button id="deletarPonto" onclick="deletarPonto()">Deletar Ponto</button>
        <button id="deletarSaida" onclick="deletarSaida()">Deletar Saida</button>
        <input id="inputCores" type="color">
        <button id="confirmCores" onclick="confirmCores()">Confirmar Cor</button>
    </div>

<script>

    // Declara o select de missoes
    const select = document.getElementById('seletorSaida')

    // Declara o select de pontos
    const pontosS = document.getElementById('seletorPonto')

    // Declara o botão de deletar
    const deletarBotao = document.getElementById('deletarPonto')

    // Define o botão de deletar como escondido
    deletarBotao.style.display = 'none'

    // Declara o input de cores
    const cores = document.getElementById('inputCores')

    // Declara a variável deletarBotaoModo
    let deletarBotaoModo = 0

    // Declara a variável de ponto selecionado
    let pontoSelect = ''

    // Declara o array de in out usados
    let InOut = []

    // Captura os pontos de base
    const pontosBase = JSON.parse(sessionStorage.getItem('pontosBase'))

    // Define o dicionário
    let pontosBaseDict = {}

   // Converte para um dicionário
   for (i = 0; i < 2; i++)
   {
        // Captura os dados necessários do pontosBase
        let [nome, cor, x, y] = pontosBase[i]

       pontosBaseDict[nome] = {'nome': nome, 'cor': cor, 'x': x, 'y': y}

       InOutPos = []
       InOutPos.push({'nome': nome, 'cor': cor, 'x': x, 'y': y})

   }

    // Declara o tamanho de coordenadas disponível
    const tamanhoCoordenadas = JSON.parse(sessionStorage.getItem('coordenadas'))



    // Event Listener adicionado
    let eventListenerSelectAtivado = false
    let eventListenerPontoAtivado = false
    let eventListenerCanvasAtivado = false
    let eventListenerCoresAtivado = false

    // Reseta o botão de cores
    document.getElementById('confirmCores').style.display = 'none'

    // Define a variável coordenadas com o array do Session Storage
    let ssCoordenadas = JSON.parse(sessionStorage.getItem('coordenadas'))

    // Botoes em uso
    let pontosUsados = []

    // Identifica o Canvas
    const c = document.getElementById('mesa')

    // Declara o canvas como um objeto 2D
    const ctx = c.getContext('2d')

    // Carrega a imagem no Canvas
    const img = document.getElementById('mesaIMG')

    // Declara o array de botoes para o modo de edição
    botoes = []

    // Coloca todas as saídas no Select
    for (i = 0; i < localStorage.length; i++)
    {
        // Define a variável key com uma chave do local storage no index de i
        let key = localStorage.key(i)
        
        // Se a key for igual a 'missoes' ou 'primeiroAcesso' vai ignorar
        if (key === 'missoes' || key === 'primeiroAcesso') continue
        
        // Cria um elemento option
        const opt = document.createElement('option')

        // Define o valor de opt com o valor da key provinda do LocalStorage
        opt.value = localStorage.getItem(key)

        // Define o título do opt com o nome da key
        opt.innerHTML = key

        // Insere o opt com título e valor
        select.appendChild(opt)

    }
    
    // Checa se o Event Listener do Select de Saída está aplicado
    if(eventListenerSelectAtivado == false)
    {
        // Adiciona o Event Listener de alteração ao select
        select.addEventListener('change', function() {

            // Coleta os valores da saida atual
            const saida = JSON.parse(this.options[this.selectedIndex].value)

            // Separa as variáveis para a cor e os pontos
            let cor = saida[0]
            let pontos = saida[1]
            InOut = saida[2]

            // Define coordenadas com as informações de pontos
            pontosUsados = pontos

            // Define o valor do input de cores como a informação de cor
            cores.value = cor

            // Define Event Listener Ativado como true
            eventListenerSelectAtivado = true
            
            // Ativa a função do Canvas
            canvas()

            // Limpar o select de pontos e aplica o padrão
            pontosS.innerHTML = ''

            pontosS.appendChild(resetPontosS())
            
            // Insere os pontos no select de pontos
            for(i = 0; i < pontosUsados.length; i++)
            {
                
                // Cria um elemento optfion
                const opt = document.createElement('option')
                
                // Aplica o valor e o texto como o ponto da lista
                opt.value = pontos[i]



                opt.innerHTML = `Ponto nº ${pontosUsados[i] + 1}`
                
                // Insere essa option ao Select de pontos
                pontosS.appendChild(opt)

                
            }

            // Adiciona uma opção de adição
            pontosS.appendChild(plusOption())

        })
    }
    
    // Checa se o Event Listener do Select de Ponto está aplicado
    if(eventListenerPontoAtivado == false)
    {
        // Adiciona o Event Listener de alteração ao select de ponto
        pontosS.addEventListener('change', function()
        {
            // Define a variável ponto como o index atual - 1
            pontoSelect = this.selectedIndex - 1
            
            
            // Se o texto da opção atual for diferente de 'Selecione um ponto'
            if(this.options[this.selectedIndex].text != 'Selecione um ponto')
            {
                // Abre a opção de editar o ponto
                editCanvas()

                // Exibe o botão para deletar o ponto
                deletarBotao.style.display = 'block'
            }
            // Caso contrário
            else
            {
                // Retorna o canvas normal
                canvas()

                // Esconde o botão para deletar o ponto
                deletarBotao.style.display = 'none'
            }
        }
    )
    }

    if(eventListenerCoresAtivado == false)
    {
        cores.addEventListener('change', function()
    {

        const saida = select.options[select.selectedIndex].text
        let LS = JSON.parse(localStorage.getItem(saida))
        LS[0] = cores.value

        canvas()

        document.getElementById('confirmCores').style.display = 'block'


    })
    }
    function canvas() 
    {

         // Limpar o Canvas Atual
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        // Se a imagem estiver carregada, aplique ao Canvas

            ctx.drawImage(img, 0, 0, 1280, 720)

            // Cria os pontos com base na tabela de coordenadas

            pontosUsados.forEach((ponto, idx) => {

                // Aplica o option para os pontos usados

                // Define os pares de coordenada do ponto atual
                let coordenadas = ssCoordenadas[ponto]

                // Define as coordenadas X e Y
                let x = coordenadas[0]
                let y = coordenadas[1]

                // Desenha o círculo na coordenada atual
                ctx.beginPath()
                ctx.arc(x, y, 15, 0, 2 * Math.PI)
                ctx.fillStyle = cores.value
                ctx.strokeStyle = cores.value
                ctx.fill()
                ctx.stroke()

                // Verifica se é o primeiro da lista
                if(idx == 0)
                {
                    // Separa cada dado do dicionário conforme a primeira base que o usuário selecionou
                    const bx = pontosBaseDict[InOut[0]].x
                    const by = pontosBaseDict[InOut[0]].y

                    // Faz a função de traçar da primeira base até o primeiro ponto
                    ctx.moveTo(bx, by)
                    ctx.lineTo(x, y)
                    ctx.lineWidth = 5
                    ctx.stroke()

                }
                // Verifica se é o último da lista
                else if (idx == pontosUsados.length - 1)
                {
                    // Separa cada dado do dicionário conforme a segunda base que o usuário selecionou
                    const bx = pontosBaseDict[InOut[1]].x
                    const by = pontosBaseDict[InOut[1]].y

                    // Faz a função de traçar do último ponto até a segunda base
                    ctx.moveTo(x, y)
                    ctx.lineTo(bx, by)
                    ctx.lineWidth = 5
                    ctx.stroke()
                }


                // Verifica se o ponto futuro existe - idx é o index do ponto atual
                if (idx < pontosUsados.length - 1) 
                {
                    // Define o index do próximo ponto listado em pontosUsados
                    const pontoF = pontosUsados[idx + 1]

                    // Define o par de coordenadas do ponto futuro
                    const coordF = ssCoordenadas[pontoF]

                    
                    // Declara as coordenadas X e Y para o ponto futuro
                    let xf = coordF[0]
                    let yf = coordF[1]

                    // Traçar a linha
                    ctx.moveTo(x, y)
                    ctx.lineTo(xf, yf)
                    ctx.lineWidth = 5
                    ctx.stroke()

                    
                }

                // Salva o estado atual do Canvas
                ctx.save()

                // Escreve o texto em outra cor, obrigando o uso do save para não haver conflitos
                ctx.font = '20px Arial'
                ctx.textAlign = 'center'

                if(cores.value == '#000000')
                {
                    ctx.fillStyle = 'white'

                }
                else
                {
                    ctx.fillStyle = 'black'

                }

                ctx.fillText(ponto + 1, x, y + 8)

                // Restaura o estado anterior juntamente com a nova alteração
                ctx.restore()


            })


            for(i = 0; i < 2; i++)
                {

                    // Captura os dados da tabela pontosBase conforme o InOut
                    let [nome, cor, x, y] = pontosBase[i]

                    // 

                    console.log(nome)

                    ctx.beginPath()
                    ctx.arc(x, y, 30, 0, 2 * Math.PI)
                    ctx.fillStyle = cor
                    ctx.strokeStyle = cor
                    ctx.fill()
                    ctx.stroke()
                    ctx.save()

                    ctx.font = '20px Arial'
                    ctx.textAlign = 'center'
                    ctx.fillStyle = 'black'
                    ctx.fillText(nome, x, y + 8)
                    ctx.restore()
                }
            
    }
  
    async function editCanvas() 
        {
            // Limpar o Canvas Atual
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            // Verifica executa se a imagem estiver carregada
            if(img.complete)
            {
                // Define a imagem do Canvas nas posições x = 0 e y = 0, com uma largura x = 1280 e altura y = 720
                ctx.drawImage(img, 0, 0, 1280, 720)
            }

            // Cria os círculos segundo uma tabela de coordenadas
            for (i = 0; i < tamanhoCoordenadas.length; i++)
            {

                // Pega as coordenadas com base na contagem 'i'
                let x = ssCoordenadas[i][0]
                let y = ssCoordenadas[i][1]
                
                // Desenha o círculo para a coordenada atual
                ctx.beginPath()
                ctx.arc(x, y, 15, 0, 2 * Math.PI)
                ctx.fillStyle = 'white'
                ctx.fill()
                ctx.strokeStyle = 'black'
                ctx.stroke()

                // ctx.save() serve para salvar o estado atual
                ctx.save()
                
                // Desenha um texto para a coordenada atual acima do círculo
                ctx.font = '20px Arial'
                ctx.textAlign = 'center'
                ctx.fillStyle = 'black'
                ctx.fillText(i + 1, x, y + 8)

                // ctx.restore() serve para restaurar o estado anterior
                ctx.restore()

                // Salva as informaçõoes de coordenada, diâmetro e nome do botão
                let botao = {'x': x, 'y': y, 'size': 20, 'nome': i}

                // Envia para o Array Botões
                botoes.push(botao)

            }

            // Detecta o clique do usuário

            let foiClicado = false

            foiClicado = await clique()

            console.log('Estado do Clique ' + foiClicado)

                if(foiClicado == true && pontosS.options[pontosS.selectedIndex].text != 'Selecione um ponto')
                {
                    
                    if(pontosS.options[pontosS.selectedIndex].text == '+')
                    {
                        // Adiciona um substituto ao elemento anterior
                        pontosS.appendChild(plusOption())
                    }
                    
                    // Define o valor de pontosUsados no index atual para o novo ponto
                    pontosUsados[pontoSelect] = botao.nome
                    
                    // Define o título da option alterada para o respectivo novo ponto
                    pontosS.options[pontosS.selectedIndex].text = `Ponto nº ${botao.nome + 1}`
                    
                    // Faz o envio das alterações para o LocalStorage
                    const saida = select.options[select.selectedIndex].text
                    
                    // Captura o valor do LocalStorage
                    let LS = JSON.parse(localStorage.getItem(saida))
                    
                    // Envia os dados
                    salvarDados(LS, pontosUsados, saida)
                    
                    
                    // Limpar array de botões
                    botoes = []
                    
                    
                    
                    // Recarrega o canvas
                    canvas()
                }
                
            }

    async function clique() 
        {
            // Aplicar o detector de clique ao Canvas
            if (eventListenerCanvasAtivado == false)
            {
            c.addEventListener('click', function(event) {

                // Define o tamanho do Canvas e a posição
                const rect = c.getBoundingClientRect()

                // Define a posição X e Y do mouse
                const mouseX = event.clientX - rect.left
                const mouseY = event.clientY - rect.top

                // Loop para detectar se algum botão foi clicado

                    botoes.forEach(botao => {
                        
                        // Lógica para detectar se o mouse está dentro das extremidades do botão
                        if (mouseX > botao.x - 10 && mouseX < botao.x + 10 && mouseY > botao.y - 10 && mouseY < botao.y + 10)
                        {
                            console.log('Clique computado')
                            return true
                        }
        })})}

            // Define o Event Listener como Já ativado
            eventListenerCanvasAtivado = true
            }

    // Função que limpa o select de pontos
    function resetPontosS()
    {

        // Cria a Option placeholder

        // Cria o objeto filho
        const stdOption = document.createElement('option')

        // Aplica propriedads como texto, valor, definindo propriedades como selected, hidden e disabled como true e retornando este objeto
        stdOption.text = 'Selecione um ponto'
        stdOption.value = ''
        stdOption.selected = true
        return stdOption

    }

    // Função que adiciona a opção adição
    function plusOption()
    {
        // Cria a opção de adicionar
        const plusOption = document.createElement('option')
        plusOption.text = '+'
        plusOption.value = ''
        return plusOption
    }

    // Função para deletar o ponto selecionado
    function deletarPonto()
    {
        // Remove o ponto atual do array de pontos usados
        pontosUsados.splice(pontoSelect, 1)

        // Seleciona a saída atual selecionada
        const saida = select.options[select.selectedIndex].text

        // Captura o localStorage original
        const LS = JSON.parse(localStorage.getItem(saida))

        // Função para realizar o salvamento dos dados
        salvarDados(LS, pontosUsados, saida)

        // Remove o ponto atual do select
        pontosS.remove(pontosS.selectedIndex)

        // Redesenha o canvas
        canvas()


    }

    // Atualizar o localStorage
    function salvarDados(ls, ps, ex)
    {
        /**
         * Faz toda a lógica de envio de dados locais para o localStorage
         * @param {array} ls - O array com os dados originais do LocalStorage
         * @param {array} ps - O array com os dados atualizados locais
         * @param {string} ex - A saída (vulgo chave) que armazenará os dados no localStorage
        */

        ls[1] = ps
        localStorage.setItem(ex, JSON.stringify(ls))
        
    }

    // Função para deletar a saída selecionada
    function deletarSaida()
    {
        // Identifica a saída atual
        const selectedOption = select.options[select.selectedIndex]
        const saidaValue = selectedOption.value
        const saidaNome = selectedOption.text

        // Confere se a saida não é nula
        if(saidaValue != null)
        {

            // Captura o localStorage atual para exibir os pontos
            let LS = JSON.parse(localStorage.getItem(saidaNome))[1]

            // Laço de repetição para corrigir o nome dos pontos (estão em ID e precisam ser transformados para um valor melhor compreensível)
            for(i = 0; i < LS.length; i++)
            {
                // Atualiza uma posição com ela mesma somada com 1
                LS[i]= LS[i] + 1
            }
            
            // Define a mensagem de confirmação usando a saída e o traçado dela
            msg = `Você está prestes a deletar a saída ${saidaNome}!
            O seguinte traçado será apagado:
            ${LS}
            
            Você tem certeza? Esta ação é irreversível!
            `

            // Executa se o usuário confirmou
            if(confirm(msg))
            {
                
                // Remove a saída selecionada do localStorage
                localStorage.removeItem(saidaNome)
                window.location.reload()
                
            }
        }
        else
        {
            window.alert('A saída atual não é válida! Selecione uma saída primeiro.')
        }
    }

    //Função para atualizar a cor
    function confirmCores()
    {
        const selectedOption = select.options[select.selectedIndex].text

        let LS = JSON.parse(localStorage.getItem(selectedOption))

        msg = `Você está prestes a substituir a cor da saída.
               Você deseja continuar?`
        if(confirm(msg))
        {

            LS[0] = cores.value
            localStorage.setItem(selectedOption, JSON.stringify(LS))

            document.getElementById('confirmCores').style.display = 'none'

        }
    }

    // Função para atualizar a base
    function editarBase()
    {
        // Captura a saída selecionada
        const saida = select.options[select.selectedIndex].text
        
        // Captura os dados da saída atual
        let LS = JSON.parse(localStorage.getItem(saida))

        // Função de editar as bases
        editarBaseCanvas()

    }

    async function editarBaseCanvas()
    {

        // Limpar o Canvas Atual
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        //Aplique a imagem ao Canvas
        ctx.drawImage(img, 0, 0, 1280, 720)

        // 

        for(i = 0; i < 2; i++)
        {

            // Captura os dados da tabela pontosBase conforme o InOut
            let nome = pontosBase[i][0]
            let cor = pontosBase[i][1]
            let x = pontosBase[i][2]
            let y = pontosBase[i][3]

            ctx.beginPath()
            ctx.arc(x, y, 30, 0, 2 * Math.PI)
            ctx.fillStyle = cor
            ctx.strokeStyle = cor
            ctx.fill()
            ctx.stroke()
            ctx.save()

            ctx.font = '20px Arial'
            ctx.textAlign = 'center'
            ctx.fillStyle = 'black'
            ctx.fillText(nome, x, y + 8)
            ctx.restore()
        }


                
            // Detecta o clique do usuário
            let foiClicado = false

            foiClicado = clique()

            if(foiClicado == true)
            {
                console.log(InOut)
            }

            }

</script>

</body>
</html>